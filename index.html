<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>無音オートカット（ブラウザ版）</title>
  <style>
    :root{
      --bg:#05070a;
      --panel:#11151c;
      --panel-soft:#181e27;
      --accent:#3ea6ff;
      --accent-soft:#15324a;
      --accent-2:#5dd39e;
      --text:#e8f1fb;
      --muted:#8ea0b8;
      --danger:#ff6b6b;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font:15px/1.6 system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",
            Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
      background:radial-gradient(circle at top,#101625 0,#05070a 55%,#02040a 100%);
      color:var(--text);
    }
    header{
      padding:18px 20px;
      border-bottom:1px solid #1b2330;
      background:linear-gradient(135deg,#070b12,#0c111b);
      position:sticky;
      top:0;
      z-index:10;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.08em;
    }
    header p{
      margin:4px 0 0;
      font-size:12px;
      color:var(--muted);
    }
    main{
      max-width:1000px;
      margin:20px auto 32px;
      padding:0 16px 24px;
    }
    .grid{
      display:grid;
      grid-template-columns: minmax(0,2fr) minmax(0,1.4fr);
      gap:18px;
    }
    @media (max-width:900px){
      .grid{grid-template-columns:1fr;}
    }
    .card{
      background:rgba(12,16,24,.96);
      border-radius:14px;
      border:1px solid rgba(255,255,255,.05);
      box-shadow:0 18px 40px rgba(0,0,0,.55);
      padding:14px 16px 16px;
    }
    .card h2{
      margin:0 0 6px;
      font-size:15px;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:#c7d5f5;
    }
    .card small{
      font-size:12px;
      color:var(--muted);
    }
    .field{
      margin-top:12px;
    }
    .field label{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
      margin-bottom:4px;
      color:#c7d5f5;
    }
    .field label span.meta{
      font-size:11px;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #222b3a;
      background:rgba(5,9,15,.9);
      color:var(--muted);
      font-size:13px;
    }
    input[type="range"]{
      width:100%;
      accent-color:var(--accent);
    }
    .slider-value{
      font-variant-numeric:tabular-nums;
      font-size:12px;
      padding:1px 8px;
      border-radius:999px;
      border:1px solid var(--accent-soft);
      background:rgba(12,20,32,.9);
      color:var(--accent-2);
    }
    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    button{
      appearance:none;
      border:none;
      border-radius:999px;
      padding:7px 14px;
      font-size:13px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:linear-gradient(135deg,var(--accent),#5dd6ff);
      color:#041018;
      font-weight:600;
      box-shadow:0 6px 14px rgba(0,0,0,.6);
      transition:transform .08s ease, box-shadow .08s ease, filter .12s ease;
    }
    button.secondary{
      background:rgba(8,13,20,.9);
      color:var(--muted);
      border:1px solid #222b3a;
      box-shadow:none;
    }
    button.danger{
      background:linear-gradient(135deg,#ff6b6b,#ff9f7a);
      color:#200708;
    }
    button:disabled{
      opacity:.4;
      cursor:default;
      transform:none;
      box-shadow:none;
      filter:none;
    }
    button:not(:disabled):hover{
      transform:translateY(-1px);
      box-shadow:0 10px 20px rgba(0,0,0,.65);
      filter:brightness(1.08);
    }
    button .dot{
      width:8px;
      height:8px;
      border-radius:999px;
      background:var(--accent-2);
    }
    button .dot.red{
      background:var(--danger);
    }
    video{
      width:100%;
      border-radius:12px;
      background:#000;
      max-height:360px;
    }
    .meta-bar{
      margin-top:6px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color:var(--muted);
    }
    .meta-pill{
      padding:3px 7px;
      border-radius:999px;
      background:rgba(18,25,36,.9);
      border:1px solid rgba(255,255,255,.04);
      font-variant-numeric:tabular-nums;
    }
    .log{
      margin-top:8px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(5,8,15,.95);
      border:1px solid #1c2431;
      font-size:11px;
      max-height:210px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .log strong{
      color:var(--accent-2);
    }
    .segments{
      margin-top:8px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(6,10,18,.96);
      border:1px dashed rgba(255,255,255,.08);
      font-size:11px;
      max-height:210px;
      overflow:auto;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 7px;
      border-radius:999px;
      font-size:10px;
      background:rgba(8,14,24,.9);
      border:1px solid rgba(255,255,255,.06);
      color:var(--muted);
    }
    .badge-dot{
      width:6px;
      height:6px;
      border-radius:50%;
      background:var(--accent-2);
    }
    a.download-link{
      display:inline-flex;
      align-items:center;
      gap:6px;
      margin-top:8px;
      font-size:13px;
      text-decoration:none;
      color:var(--accent-2);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(8,16,22,.95);
      border:1px solid var(--accent-soft);
    }
  </style>
</head>
<body>
<header>
  <h1>無音オートカット（ffmpeg.wasm）</h1>
  <p>指定デシベル以下の無音区間を検出し、話している部分だけを自動で繋いだ動画を生成します。</p>
</header>

<main>
  <div class="grid">
    <!-- 左：入力 & 設定 -->
    <section class="card">
      <h2>1. 入力動画 & しきい値</h2>
      <small>iPad / PC の Safari・Chrome で動作するブラウザアプリです。</small>

      <div class="field">
        <label>
          動画ファイルを選択（mp4 推奨）
          <span class="meta">端末から直接読み込み / アップロードは行いません</span>
        </label>
        <input type="file" id="fileInput" accept="video/*" />
      </div>

      <div class="field">
        <label>
          無音判定しきい値（dB）
          <span class="meta">値が 0 に近いほど「小さな音も無音扱い」になります</span>
        </label>
        <input type="range" id="thresholdSlider" min="-60" max="-10" step="1" value="-35" />
        <div class="slider-value" id="thresholdValue">-35 dB</div>
      </div>

      <div class="field">
        <label>
          無音継続時間（秒）
          <span class="meta">この秒数以上続いたら無音ブロックとみなします</span>
        </label>
        <input type="range" id="minSilenceSlider" min="0.1" max="1.5" step="0.1" value="0.4" />
        <div class="slider-value" id="minSilenceValue">0.4 秒</div>
      </div>

      <div class="field">
        <label>
          セーフティマージン（秒）
          <span class="meta">無音の前後を少しだけ残して、単語の切れを防ぎます</span>
        </label>
        <input type="range" id="marginSlider" min="0" max="0.4" step="0.05" value="0.08" />
        <div class="slider-value" id="marginValue">0.08 秒</div>
      </div>

      <div class="btn-row">
        <button id="analyzeBtn" disabled>
          <span class="dot"></span> 無音を解析する
        </button>
        <button id="previewBtn" class="secondary" disabled>
          無音カットでプレビュー再生
        </button>
        <button id="exportBtn" class="secondary" disabled>
          書き出し（MP4生成）
        </button>
        <button id="resetBtn" class="secondary">
          リセット
        </button>
      </div>

      <div class="meta-bar" id="videoMeta" hidden>
        <div class="meta-pill" id="metaName"></div>
        <div class="meta-pill" id="metaDuration"></div>
        <div class="meta-pill" id="metaSize"></div>
      </div>

      <div class="field">
        <label>
          ステータス
          <span class="meta">処理の進行状況や ffmpeg のメッセージ</span>
        </label>
        <div class="log" id="logArea">
          <strong>準備完了：</strong>動画を選択してください。
        </div>
      </div>
    </section>

    <!-- 右：プレビュー & セグメント -->
    <section class="card">
      <h2>2. プレビュー & セグメント</h2>
      <small>解析後、話している部分のみを再生 / 書き出しできます。</small>

      <div class="field">
        <label>
          プレビュー
          <span class="meta">ブラウザ上でのみ再生されます（アップロードされません）</span>
        </label>
        <video id="previewVideo" controls playsinline></video>
      </div>

      <div class="field">
        <label>
          検出された「会話セグメント」
          <span class="meta">無音区間を元に自動算出された「残す区間」の一覧</span>
        </label>
        <div class="segments" id="segmentsArea">
          まだ解析されていません。<br>
          「無音を解析する」ボタンを押すと、ここに残す区間が表示されます。
        </div>
      </div>

      <div class="field" id="downloadArea" hidden>
        <label>
          書き出し結果
          <span class="meta">端末に MP4 として保存できます</span>
        </label>
        <a id="downloadLink" class="download-link" href="#" download="cut-output.mp4">
          <span class="badge-dot"></span>
          <span>無音カット済み動画をダウンロード</span>
        </a>
      </div>
    </section>
  </div>
</main>

<!-- ffmpeg.wasm (UMD版) -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
<script>
  (() => {
    const { createFFmpeg, fetchFile } = FFmpeg;

    const ffmpeg = createFFmpeg({
      log: true,
      corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js'
    });

    /*** DOM 取得 ***/
    const fileInput       = document.getElementById('fileInput');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdValue  = document.getElementById('thresholdValue');
    const minSilenceSlider= document.getElementById('minSilenceSlider');
    const minSilenceValue = document.getElementById('minSilenceValue');
    const marginSlider    = document.getElementById('marginSlider');
    const marginValue     = document.getElementById('marginValue');

    const analyzeBtn      = document.getElementById('analyzeBtn');
    const previewBtn      = document.getElementById('previewBtn');
    const exportBtn       = document.getElementById('exportBtn');
    const resetBtn        = document.getElementById('resetBtn');

    const logArea         = document.getElementById('logArea');
    const videoMeta       = document.getElementById('videoMeta');
    const metaName        = document.getElementById('metaName');
    const metaDuration    = document.getElementById('metaDuration');
    const metaSize        = document.getElementById('metaSize');

    const previewVideo    = document.getElementById('previewVideo');
    const segmentsArea    = document.getElementById('segmentsArea');
    const downloadArea    = document.getElementById('downloadArea');
    const downloadLink    = document.getElementById('downloadLink');

    /*** 状態管理 ***/
    let loaded = false;
    let currentFile = null;
    let currentFileName = '';
    let videoDuration = 0;
    let silenceRanges = [];
    let keepSegments = [];
    let previewIndex = 0;
    let analyzing = false;
    let exporting = false;

    /*** ユーティリティ ***/
    const pad = (n) => String(Math.floor(n)).padStart(2,'0');
    const formatTime = (sec) => {
      const s = Math.max(0, sec || 0);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const r = s % 60;
      if (h > 0) return `${h}:${pad(m)}:${r.toFixed(2).padStart(5,'0')}`;
      return `${m}:${r.toFixed(2).padStart(5,'0')}`;
    };
    const log = (msg, isStrong=false) => {
      const t = new Date();
      const ts = `${pad(t.getHours())}:${pad(t.getMinutes())}:${pad(t.getSeconds())}`;
      const line = `[${ts}] ${msg}\n`;
      if (isStrong) {
        logArea.innerHTML = `<strong>${msg}</strong>\n` + logArea.innerHTML;
      } else {
        logArea.textContent = line + logArea.textContent;
      }
    };
    const clearFS = () => {
      try {
        ['input.mp4','list.txt','output.mp4'].forEach(f => {
          try{ ffmpeg.FS('unlink', f); }catch(e){}
        });
        // 部分ファイル削除
        for(let i=0;i<256;i++){
          try{ ffmpeg.FS('unlink', `part${i}.mp4`); }catch(e){}
        }
      } catch(e){}
    };

    /*** スライダーの表示更新 ***/
    thresholdSlider.addEventListener('input', () => {
      thresholdValue.textContent = `${thresholdSlider.value} dB`;
    });
    minSilenceSlider.addEventListener('input', () => {
      minSilenceValue.textContent = `${Number(minSilenceSlider.value).toFixed(1)} 秒`;
    });
    marginSlider.addEventListener('input', () => {
      marginValue.textContent = `${Number(marginSlider.value).toFixed(2)} 秒`;
    });

    /*** ffmpeg ロガー：silencedetect の出力を拾う ***/
    ffmpeg.setLogger(({ type, message }) => {
      // 進捗が多いので詳細ログは必要に応じてコメントアウト
      if (type === 'fferr' || message.includes('silence_')) {
        if (message.includes('silence_start:')) {
          const v = parseFloat(message.split('silence_start:')[1]);
          if (!Number.isNaN(v)) {
            silenceRanges.push({ start: v, end: null });
          }
        } else if (message.includes('silence_end:')) {
          const v = parseFloat(message.split('silence_end:')[1]);
          if (!Number.isNaN(v)) {
            // 直前の start に end を付与
            for (let i = silenceRanges.length - 1; i >= 0; i--) {
              if (silenceRanges[i].end === null) {
                silenceRanges[i].end = v;
                break;
              }
            }
          }
        }
      }
    });

    /*** ffmpeg のロード ***/
    const ensureFFmpeg = async () => {
      if (!loaded) {
        log('ffmpeg.wasm をロードしています…（数秒〜数十秒かかることがあります）');
        await ffmpeg.load();
        loaded = true;
        log('ffmpeg.wasm のロードが完了しました。', true);
      }
    };

    /*** ファイル選択処理 ***/
    fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  currentFile = file;
  currentFileName = file.name;
  silenceRanges = [];
  keepSegments = [];
  videoDuration = 0;
  downloadArea.hidden = true;
  downloadLink.href = '#';

  // ★ ここでログをリセットして「ファイル受信」を表示
  logArea.textContent = '';
  log(`動画ファイルを受け取りました：${file.name}`, true);

  // プレビュー用 URL
  const url = URL.createObjectURL(file);
  previewVideo.src = url;
  previewVideo.load();

  // メタ情報
  const sizeMB = file.size / (1024 * 1024);
  metaName.textContent = file.name;
  metaSize.textContent = `サイズ: ${sizeMB.toFixed(1)} MB`;
  videoMeta.hidden = false;
  segmentsArea.innerHTML = '動画メタデータの読込中…';

  // duration を取得
  previewVideo.onloadedmetadata = () => {
    videoDuration = previewVideo.duration || 0;
    metaDuration.textContent = `長さ: ${formatTime(videoDuration)}`;
    segmentsArea.innerHTML =
      '動画の準備ができました。「無音を解析する」を押して処理を開始してください。';
    analyzeBtn.disabled = false;
    previewBtn.disabled = true;
    exportBtn.disabled = true;

    // ★ ここでもう一度ログ
    log(`動画を読み込みました：${file.name}（${sizeMB.toFixed(1)} MB, ${formatTime(videoDuration)}）`, true);
  };
});


    /*** 無音解析 → keepセグメント計算 ***/
    const analyzeSilence = async () => {
      if (!currentFile) {
        log('動画が選択されていません。', true);
        return;
      }
      if (videoDuration === 0 || !Number.isFinite(videoDuration)) {
        log('動画の長さを取得できませんでした。もう一度ファイルを選択してください。', true);
        return;
      }
      if (analyzing) return;
      analyzing = true;
      analyzeBtn.disabled = true;
      previewBtn.disabled = true;
      exportBtn.disabled = true;
      downloadArea.hidden = true;
      segmentsArea.textContent = '無音区間を解析中…';

      try {
        await ensureFFmpeg();
        clearFS();
        silenceRanges = [];
        keepSegments = [];

        log('入力ファイルを書き込み中（仮想ファイルシステム）…');
        ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(currentFile));

        const noise = thresholdSlider.value;   // 例：-35
        const dSil = Number(minSilenceSlider.value) || 0.4;

        log(`silencedetect で解析します（noise=${noise}dB, d=${dSil}s）`);
        await ffmpeg.run(
          '-i', 'input.mp4',
          '-vn',
          '-af', `silencedetect=noise=${noise}dB:d=${dSil}`,
          '-f', 'null',
          '-'
        );
        log('無音解析が完了しました。');

        // silenceRanges を整理
        const normalized = silenceRanges
          .filter(r => r.start != null && r.end != null && r.end > r.start)
          .sort((a,b) => a.start - b.start);

        const margin = Number(marginSlider.value) || 0;
        const minKeep = 0.25; // 残す区間の最小秒数

        const segs = [];
        let cursor = 0;

        for (const s of normalized) {
          const start = Math.max(cursor, 0);
          const end   = Math.max(0, s.start - margin);
          if (end - start >= minKeep) {
            segs.push({ start, end });
          }
          cursor = s.end + margin;
        }
        if (videoDuration - cursor >= minKeep) {
          segs.push({ start: cursor, end: videoDuration });
        }

        keepSegments = segs;

        if (!segs.length) {
          segmentsArea.innerHTML =
            '有効な会話セグメントが検出されませんでした。しきい値（dB）を大きくするか、無音継続時間を短くして再度お試しください。';
          previewBtn.disabled = true;
          exportBtn.disabled = true;
          log('残すべきセグメントがありませんでした。', true);
        } else {
          const listHtml = [];
          listHtml.push(`<div class="badge"><span class="badge-dot"></span> 残す区間：${segs.length} 個</div>`);
          listHtml.push('<div style="margin-top:6px;">');
          segs.forEach((s,i) => {
            listHtml.push(
              `#${i+1} : ` +
              `${formatTime(s.start)} 〜 ${formatTime(s.end)} ` +
              `（${(s.end - s.start).toFixed(2)} 秒）`
            );
          });
          listHtml.push('</div>');
          segmentsArea.innerHTML = listHtml.join('<br>');

          previewBtn.disabled = false;
          exportBtn.disabled  = false;
          log(`残す会話セグメントを ${segs.length} 個検出しました。`, true);
        }

      } catch (err) {
        console.error(err);
        log(`無音解析中にエラーが発生しました: ${err.message || err}`, true);
        segmentsArea.textContent = 'エラーが発生しました。動画やブラウザを変えて再度お試しください。';

      } finally {
        analyzing = false;
        analyzeBtn.disabled = false;
      }
    };

    /*** プレビュー再生（無音カットでスキップ再生） ***/
    const startPreviewPlay = () => {
      if (!keepSegments.length || !currentFile) {
        log('まず「無音を解析する」を実行してください。', true);
        return;
      }
      previewIndex = 0;
      const first = keepSegments[0];
      previewVideo.currentTime = first.start;
      previewVideo.play()
        .then(() => {
          log('無音カットプレビューを開始しました。');
        })
        .catch(e => {
          log(`再生開始に失敗しました: ${e.message || e}`, true);
        });
    };

    previewVideo.addEventListener('timeupdate', () => {
      if (!keepSegments.length) return;
      if (previewVideo.paused || previewVideo.seeking) return;

      const t = previewVideo.currentTime;
      const seg = keepSegments[previewIndex];
      if (!seg) {
        // all done
        previewVideo.pause();
        return;
      }
      if (t >= (seg.end - 0.03)) {
        previewIndex++;
        const next = keepSegments[previewIndex];
        if (next) {
          previewVideo.currentTime = next.start;
        } else {
          previewVideo.pause();
        }
      }
    });

    /*** 書き出し処理（concat demuxer） ***/
    const exportVideo = async () => {
      if (!keepSegments.length || !currentFile) {
        log('残すセグメントがありません。まず無音解析を行ってください。', true);
        return;
      }
      if (exporting) return;
      exporting = true;
      exportBtn.disabled = true;
      analyzeBtn.disabled = true;
      previewBtn.disabled = true;
      downloadArea.hidden = true;

      try {
        await ensureFFmpeg();
        clearFS();
        ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(currentFile));

        log(`会話セグメント ${keepSegments.length} 個を部分ファイルとして切り出します…`);
        const parts = [];
        let index = 0;
        for (const seg of keepSegments) {
          const start = Math.max(0, seg.start);
          const end   = Math.min(videoDuration, seg.end);
          if (end <= start) continue;

          const outName = `part${index}.mp4`;
          parts.push(outName);

          log(`  - 部分 #${index+1}: ${formatTime(start)}〜${formatTime(end)} を切り出し`);
          await ffmpeg.run(
            '-ss', start.toFixed(3),
            '-to', end.toFixed(3),
            '-i', 'input.mp4',
            '-c', 'copy',
            outName
          );
          index++;
        }

        if (!parts.length) {
          log('有効な部分動画が作成できませんでした。', true);
          return;
        }

        let listContent = '';
        parts.forEach(p => {
          listContent += `file '${p}'\n`;
        });
        ffmpeg.FS('writeFile', 'list.txt', new TextEncoder().encode(listContent));

        log('部分ファイルを concat demuxer で結合しています…');
        await ffmpeg.run(
          '-f','concat','-safe','0',
          '-i','list.txt',
          '-c','copy',
          'output.mp4'
        );

        const data = ffmpeg.FS('readFile', 'output.mp4');
        const blob = new Blob([data.buffer], { type:'video/mp4' });
        const url  = URL.createObjectURL(blob);

        const baseName = currentFileName.replace(/\.[^.]+$/, '');
        downloadLink.href = url;
        downloadLink.download = `${baseName}_cut.mp4`;
        downloadArea.hidden = false;

        log('書き出しが完了しました。ダウンロードリンクから保存してください。', true);

      } catch (err) {
        console.error(err);
        log(`書き出し中にエラーが発生しました: ${err.message || err}`, true);
      } finally {
        exporting = false;
        exportBtn.disabled = false;
        analyzeBtn.disabled = false;
        previewBtn.disabled = false;
      }
    };

    /*** リセット ***/
    const resetAll = () => {
      currentFile = null;
      currentFileName = '';
      videoDuration = 0;
      silenceRanges = [];
      keepSegments = [];
      previewIndex = 0;
      fileInput.value = '';
      previewVideo.removeAttribute('src');
      previewVideo.load();
      segmentsArea.innerHTML =
        'リセットしました。動画を選択し直して「無音を解析する」を実行してください。';
      downloadArea.hidden = true;
      downloadLink.href = '#';
      analyzeBtn.disabled = true;
      previewBtn.disabled = true;
      exportBtn.disabled = true;
      videoMeta.hidden = true;
      log('状態をリセットしました。');
    };

    /*** ボタンイベント ***/
    analyzeBtn.addEventListener('click', analyzeSilence);
    previewBtn.addEventListener('click', startPreviewPlay);
    exportBtn.addEventListener('click', exportVideo);
    resetBtn.addEventListener('click', resetAll);

    log('準備完了：まずは動画ファイルを選択してください。', true);
  })();
</script>
</body>
</html>
